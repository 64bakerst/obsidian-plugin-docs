"use strict";(self.webpackChunkobsidian_plugin_docs=self.webpackChunkobsidian_plugin_docs||[]).push([[6532],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,u=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),g=l(n),d=i,m=g["".concat(u,".").concat(d)]||g[d]||p[d]||o;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=g;var a={};for(var u in t)hasOwnProperty.call(t,u)&&(a[u]=t[u]);a.originalType=e,a.mdxType="string"==typeof e?e:i,s[1]=a;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},16378:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return u},metadata:function(){return l},toc:function(){return c},default:function(){return g}});var r=n(87462),i=n(63366),o=(n(67294),n(3905)),s=["components"],a={},u="EditorSuggest",l={unversionedId:"api/classes/EditorSuggest",id:"api/classes/EditorSuggest",isDocsHomePage:!1,title:"EditorSuggest",description:"Extends PopoverSuggest",source:"@site/docs/api/classes/EditorSuggest.md",sourceDirName:"api/classes",slug:"/api/classes/EditorSuggest",permalink:"/obsidian-plugin-docs/api/classes/EditorSuggest",editUrl:"https://github.com/marcusolsson/obsidian-plugin-docs/edit/main/docs/api/classes/EditorSuggest.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Editor",permalink:"/obsidian-plugin-docs/api/classes/Editor"},next:{title:"Events",permalink:"/obsidian-plugin-docs/api/classes/Events"}},c=[{value:"Constructor",id:"constructor",children:[]},{value:"Properties",id:"properties",children:[{value:"context",id:"context",children:[]},{value:"limit",id:"limit",children:[]}]},{value:"Methods",id:"methods",children:[{value:"setInstructions",id:"setinstructions",children:[]},{value:"onTrigger",id:"ontrigger",children:[]},{value:"getSuggestions",id:"getsuggestions",children:[]}]}],p={toc:c};function g(e){var t=e.components,n=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"editorsuggest"},"EditorSuggest"),(0,o.kt)("p",null,"Extends ",(0,o.kt)("inlineCode",{parentName:"p"},"PopoverSuggest<T>")),(0,o.kt)("h2",{id:"constructor"},"Constructor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"constructor(app: App);\n")),(0,o.kt)("h2",{id:"properties"},"Properties"),(0,o.kt)("h3",{id:"context"},"context"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"context: EditorSuggestContext\n")),(0,o.kt)("p",null,"Current suggestion context, containing the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"onTrigger"),".\nThis will be null any time the EditorSuggest is not supposed to run."),(0,o.kt)("h3",{id:"limit"},"limit"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"limit: number\n")),(0,o.kt)("p",null,"Override this to use a different limit for suggestion items"),(0,o.kt)("h2",{id:"methods"},"Methods"),(0,o.kt)("h3",{id:"setinstructions"},"setInstructions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"setInstructions(instructions: Instruction[]): void;\n")),(0,o.kt)("h3",{id:"ontrigger"},"onTrigger"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"abstract onTrigger(cursor: EditorPosition, editor: Editor, file: TFile): EditorSuggestTriggerInfo | null;\n")),(0,o.kt)("p",null,"Based on the editor line and cursor position, determine if this EditorSuggest should be triggered at this moment.\nTypically, you would run a regular expression on the current line text before the cursor.\nReturn null to indicate that this editor suggest is not supposed to be triggered."),(0,o.kt)("p",null,"Please be mindful of performance when implementing this function, as it will be triggered very often (on each keypress).\nKeep it simple, and return null as early as possible if you determine that it is not the right time."),(0,o.kt)("h3",{id:"getsuggestions"},"getSuggestions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"abstract getSuggestions(context: EditorSuggestContext): T[] | Promise<T[]>;\n")),(0,o.kt)("p",null,"Generate suggestion items based on this context. Can be async, but preferably sync.\nWhen generating async suggestions, you should pass the context along."))}g.isMDXComponent=!0}}]);